'''=================
Описание задачи:
=================
Разработать функционал "навигации по лабиринту": имея карту лабиринта, координаты стартовой точки и маршрут, требуется определить
координаты конечной точки.
- Лабиринт представляется в виде набора секций на двумерной плоскости.
-- Положение секции определяется двумя целочисленными координатами, например секция (0, 2).
-- Если две секции расположены рядом по горизонтали или вертикали (не по диагонали), то между ними есть проход.
-- Например:
--- набор секций с координатами (0, 0), (0, 1), (1, 0), (1, 1) задает квадратный лабиринт 2x2.
--- набор секций с координатами (-1, 0), (0, 0), (1, 0), (0, 1), (0, -1) задает лабиринт из 5 секций в виде креста
с центром в секции (0, 0).
-- Лабиринт может иметь произвольную форму, состоять из нескольких не связанных между собой частей и т. д.
- Маршрут в лабиринте задается последовательностью шагов.
-- Шагать можно только по 4 направлениям: вверх, вниз, вправо и влево.
-- Если в направлении шага есть переход в соседнюю секцию, то текущее положение меняется на нее.
-- Если в направлении шага перехода в соседнюю секцию нет, то шаг не имеет эффекта и текущее положение не меняется.
-- Например, для лабиринта из двух секций (0, 0) и (1, 0), стартовой точки (0, 0) и маршрута "вправо, вправо, вправо",
только первый шаг будет иметь эффект (0, 0) -> (1, 0). Второй и третий шаг оставят текущее положение без изменений,
поскольку секции (2, 0) не существует, и конечная точка маршрута останется (1, 0).
- Требуется определить положение после последнего шага маршрута.
Требования к реализации:
========================
- Требуется реализовать этот функционал в виде проекта на python, а также снабдить его тестами на pytest
- Выбор деталей реализации (API, обработка ошибок, кол-во и содержание тестов, документация, проч.) остается на ваше усмотрение
- При этом:
-- Представьте, что этот функционал будет доступен другим пользователям, которым потребуется понимать его возможности и
особенности использования, не вникая в реализацию / не читая её, в том числе в ошибочных ситуациях
-- Представьте, что вы работаете над этим проектом совместно с другими разработчиками, и кому-то другому может понадобиться
понять реализацию / внести изменения в имеющийся функционал - возможно, уже без вашего участия. Учитывая это, оформите его
содержимое в соответствии с теми best practiсes, с которыми знакомы и считаете правильными
-- Не требуется "идеальная" реализация - остановитесь в, на ваш взгляд, наиболее приемлемый по соотношению качества к
затраченному времени момент Мы с интересом просмотрим Ваше решение, даже если не все пункты будут выполнены. Также, если у Вас
возникнут вопросы по условиям задания, то не стесняйтесь написать нам!'''

import argparse
from maze_templates import *

maze_dict = {
            'a':{'type':a, 'zero_p':zero_point_a, 'finish':finish_a},
            'b':{'type':b, 'zero_p':zero_point_b, 'finish':finish_b},
            'c':{'type':c, 'zero_p':zero_point_c, 'finish':finish_c},
}
maze = ''
labyrinth = maze_dict[maze]
zero_point = labyrinth['zero_p']
finish = labyrinth['finish']

way = ['u','r','d', 'l', 'd', 'l', 'u', 'r', 'u', 'r']
new_point = []

def move(point, course, lab):
    x, y = point[0], point[1]
    if course == 'r' and (point[0]+1, point[1]) in lab:
        x+=1
    if course == 'l' and (point[0]-1, point[1]) in lab:
        x-=1
    if course == 'u' and (point[0], point[1]+1) in lab:
        y+=1
    if course == 'd' and (point[0], point[1]-1) in lab:
        y-=1
    new_point = [x, y]
    return new_point

def steper(lab, z_point, way):
    if len(way) == 1:
        new_position = move(z_point,way, lab)
        return new_position
    else:
        step = way.pop(0)
        new_position = move(z_point, step, lab)
        steper(lab, new_position, way)


parser = argparse.ArgumentParser(description='Great Description To Be Here')
parser.add_argument('-w', dest=way, help='Введите шаги через ","')
parser.add_argument('-m', dest=maze, help='Выберите тип лабиринта: a, b, c')

if __name__ == "__main__":
    new_p = steper(labyrinth, zero_point, way)
    if new_p == finish:
        print('You win')
    else:
        print(f'Finish {finish}')
        print(f'Your position {new_p}')

