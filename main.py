'''=================
Описание задачи:
=================
Разработать функционал "навигации по лабиринту": имея карту лабиринта, координаты стартовой точки и маршрут, требуется определить
координаты конечной точки.
- Лабиринт представляется в виде набора секций на двумерной плоскости.
-- Положение секции определяется двумя целочисленными координатами, например секция (0, 2).
-- Если две секции расположены рядом по горизонтали или вертикали (не по диагонали), то между ними есть проход.
-- Например:
--- набор секций с координатами (0, 0), (0, 1), (1, 0), (1, 1) задает квадратный лабиринт 2x2.
--- набор секций с координатами (-1, 0), (0, 0), (1, 0), (0, 1), (0, -1) задает лабиринт из 5 секций в виде креста
с центром в секции (0, 0).
-- Лабиринт может иметь произвольную форму, состоять из нескольких не связанных между собой частей и т. д.
- Маршрут в лабиринте задается последовательностью шагов.
-- Шагать можно только по 4 направлениям: вверх, вниз, вправо и влево.
-- Если в направлении шага есть переход в соседнюю секцию, то текущее положение меняется на нее.
-- Если в направлении шага перехода в соседнюю секцию нет, то шаг не имеет эффекта и текущее положение не меняется.
-- Например, для лабиринта из двух секций (0, 0) и (1, 0), стартовой точки (0, 0) и маршрута "вправо, вправо, вправо",
только первый шаг будет иметь эффект (0, 0) -> (1, 0). Второй и третий шаг оставят текущее положение без изменений,
поскольку секции (2, 0) не существует, и конечная точка маршрута останется (1, 0).
- Требуется определить положение после последнего шага маршрута.
Требования к реализации:
========================
- Требуется реализовать этот функционал в виде проекта на python, а также снабдить его тестами на pytest
- Выбор деталей реализации (API, обработка ошибок, кол-во и содержание тестов, документация, проч.) остается на ваше усмотрение
- При этом:
-- Представьте, что этот функционал будет доступен другим пользователям, которым потребуется понимать его возможности и
особенности использования, не вникая в реализацию / не читая её, в том числе в ошибочных ситуациях
-- Представьте, что вы работаете над этим проектом совместно с другими разработчиками, и кому-то другому может понадобиться
понять реализацию / внести изменения в имеющийся функционал - возможно, уже без вашего участия. Учитывая это, оформите его
содержимое в соответствии с теми best practiсes, с которыми знакомы и считаете правильными
-- Не требуется "идеальная" реализация - остановитесь в, на ваш взгляд, наиболее приемлемый по соотношению качества к
затраченному времени момент Мы с интересом просмотрим Ваше решение, даже если не все пункты будут выполнены. Также, если у Вас
возникнут вопросы по условиям задания, то не стесняйтесь написать нам!'''

def move(point, course, lab):
    x, y = point[0], point[1]
    if course == 'r' and (point[0]+1, point[1]) in lab:
        x+=1
    if course == 'l' and (point[0]-1, point[1]) in lab:
        x-=1
    if course == 'u' and (point[0], point[1]+1) in lab:
        y+=1
    if course == 'd' and (point[0], point[1]-1) in lab:
        y-=1
    new_point = [x, y]
    return new_point

def steper(lab, z_point, way):
    if len(way) == 1:
        new_position = move(z_point,way[0], lab)
        return new_position
    else:
        step = way.pop(0)
        new_position = move(z_point, step, lab)
        return steper(lab, new_position, way)

if __name__ == "__main__":
    import argparse
    from maze_templates import *
    import re

    maze_dict = {
        'a': {'type': a, 'zero_p': zero_point_a, 'finish': finish_a},
        'b': {'type': b, 'zero_p': zero_point_b, 'finish': finish_b},
        'c': {'type': c, 'zero_p': zero_point_c, 'finish': finish_c},
    }

    parser = argparse.ArgumentParser(description='Great Description To Be Here')
    parser.add_argument('-w', '--way', dest='way', default='r,u', type=str,
                        help='Введите шаги, например: l,r,u,d или  lrud')
    parser.add_argument('-m', '--maze', dest='maze', default='a', choices=['a', 'b', 'c'], type=str,
                        help='Выберите тип лабиринта: a, b или c')
    parser.add_argument('-d', '--debug', dest='debug', action='store_true',
                        help='Вывод отладочно информации')
    args = parser.parse_args()

    way_list = re.findall('[u]|[r]|[l]|[d]', args.way)
    labyrinth = maze_dict[args.maze]
    zero_point = labyrinth['zero_p']
    finish = labyrinth['finish']

    if args.debug:
        print(f'way_list: {way_list} \nlabyrinth: {labyrinth} \nzero_point: {zero_point}')

    new_p = steper(labyrinth['type'], zero_point, way_list)
    print(f'Your position {new_p}')
    #
    # if tuple(new_p) == finish:
    #     print('You win')
    # else:
    #     print(f'Finish {finish}')

