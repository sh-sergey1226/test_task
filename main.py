'''=================
Описание задачи:
=================
Разработать функционал "навигации по лабиринту": имея карту лабиринта, координаты стартовой точки и маршрут, требуется определить
координаты конечной точки.
- Лабиринт представляется в виде набора секций на двумерной плоскости.
-- Положение секции определяется двумя целочисленными координатами, например секция (0, 2).
-- Если две секции расположены рядом по горизонтали или вертикали (не по диагонали), то между ними есть проход.
-- Например:
--- набор секций с координатами (0, 0), (0, 1), (1, 0), (1, 1) задает квадратный лабиринт 2x2.
--- набор секций с координатами (-1, 0), (0, 0), (1, 0), (0, 1), (0, -1) задает лабиринт из 5 секций в виде креста
с центром в секции (0, 0).
-- Лабиринт может иметь произвольную форму, состоять из нескольких не связанных между собой частей и т. д.
- Маршрут в лабиринте задается последовательностью шагов.
-- Шагать можно только по 4 направлениям: вверх, вниз, вправо и влево.
-- Если в направлении шага есть переход в соседнюю секцию, то текущее положение меняется на нее.
-- Если в направлении шага перехода в соседнюю секцию нет, то шаг не имеет эффекта и текущее положение не меняется.
-- Например, для лабиринта из двух секций (0, 0) и (1, 0), стартовой точки (0, 0) и маршрута "вправо, вправо, вправо",
только первый шаг будет иметь эффект (0, 0) -> (1, 0). Второй и третий шаг оставят текущее положение без изменений,
поскольку секции (2, 0) не существует, и конечная точка маршрута останется (1, 0).
- Требуется определить положение после последнего шага маршрута.
Требования к реализации:
========================
- Требуется реализовать этот функционал в виде проекта на python, а также снабдить его тестами на pytest
- Выбор деталей реализации (API, обработка ошибок, кол-во и содержание тестов, документация, проч.) остается на ваше усмотрение
- При этом:
-- Представьте, что этот функционал будет доступен другим пользователям, которым потребуется понимать его возможности и
особенности использования, не вникая в реализацию / не читая её, в том числе в ошибочных ситуациях
-- Представьте, что вы работаете над этим проектом совместно с другими разработчиками, и кому-то другому может понадобиться
понять реализацию / внести изменения в имеющийся функционал - возможно, уже без вашего участия. Учитывая это, оформите его
содержимое в соответствии с теми best practiсes, с которыми знакомы и считаете правильными
-- Не требуется "идеальная" реализация - остановитесь в, на ваш взгляд, наиболее приемлемый по соотношению качества к
затраченному времени момент Мы с интересом просмотрим Ваше решение, даже если не все пункты будут выполнены. Также, если у Вас
возникнут вопросы по условиям задания, то не стесняйтесь написать нам!'''


f = None

zero_point= (0, 0)

labyrinth = ((0, 3), (1, 3), (2, 3), (3, 3),
             (0, 2), (1, 2), (2, 2), (3, 2),
             (0, 1), (1, 1), (2, 1), (3, 1),
             (0, 0), (1, 0), (2, 0), (3, 0))

labyrinth2 = ((0, 3), (1, 3), (2, 3), (3, 3),
              (0, 2), (f, f), (f, f), (3, 2),
              (0, 1), (f, f), (f, f), (3, 1),
              (0, 0), (1, 0), (f, f), (3, 0))

way = ['u','r','d', 'l', 'd', 'l', 'u', 'r', 'u', 'r']
new_point = []
# x, y = zero_point[0], zero_point[1]
#
# for step in way:
#     if step == 'u':
#         y += 1
#         if (x,y) in labyrinth2:
#             new_point = [x, y]
#         else:
#             y-=1
#     if step == 'r':
#         x +=1
#         if (x,y) in labyrinth2:
#             new_point = [x, y]
#         else:
#             x -= 1
#     if step == 'd':
#         y -= 1
#         if (x,y) in labyrinth2:
#             new_point = [x, y]
#         else:
#             y += 1
#     if step == 'l':
#         x -=1
#         if (x,y) in labyrinth2:
#             new_point = [x, y]
#         else:
#             x += 1
#
# print('simple loop', new_point)


def move(point, course, lab):
    x, y = point[0], point[1]
    if course == 'r' and (point[0]+1, point[1]) in lab:
        x+=1
    if course == 'l' and (point[0]-1, point[1]) in lab:
        x-=1
    if course == 'u' and (point[0], point[1]+1) in lab:
        y+=1
    if course == 'd' and (point[0], point[1]-1) in lab:
        y-=1
    new_point = [x, y]
    return new_point

def steper(lab, z_point, way):
    if len(way) == 1:
        new_position = move(z_point,way, lab)
        print('recurs func', new_position)
        return new_position
    else:
        step = way.pop(0)
        new_position = move(z_point, step, lab)
        steper(lab, new_position, way)

steper(labyrinth2, zero_point, way)


if __name__ == "__main__":
    steper()